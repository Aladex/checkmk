#!/usr/bin/env python3
# Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2
# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and
# conditions defined in the file COPYING, which is part of this source code package.

import time
from typing import Any, Iterable, Mapping, NamedTuple, Sequence

from cmk.base.plugins.agent_based.agent_based_api.v1 import render
from cmk.base.plugins.agent_based.agent_based_api.v1.type_defs import StringTable

# <<<mssql_backup>>>
# MSSQL_SQLEXPRESS1 test123 1331207325

# <<<mssql_backup>>>
# MSSQL_SQL0x2 master 2016-07-08 20:20:27
# MSSQL_SQL0x2 model 2016-07-08 20:20:28
# MSSQL_SQL0x2 model 2016-07-12 09:09:42
# MSSQL_SQL0x2 model 2016-07-11 20:20:07
# MSSQL_SQL0x2 msdb 2016-07-08 20:20:43
# MSSQL_SQL0x2 msdb 2016-07-11 20:20:07

# <<<mssql_backup>>>
# MSSQL_SQL0x3 master 2016-07-08 20:20:27 D
# MSSQL_SQL0x3 model 2016-07-08 20:20:28 D
# MSSQL_SQL0x3 model 2016-07-12 09:09:42 L
# MSSQL_SQL0x3 model 2016-07-11 20:20:07 I
# MSSQL_SQL0x3 msdb 2016-07-08 20:20:43 D
# MSSQL_SQL0x3 msdb 2016-07-11 20:20:07 I

# <<<mssql_backup:sep(124)>>>
# MSSQL_SQL0x4|master|2016-07-08 20:20:27|D
# MSSQL_SQL0x4|model|2016-07-08 20:20:28|D
# MSSQL_SQL0x4|model|2016-07-12 09:09:42|L
# MSSQL_SQL0x4|model|2016-07-11 20:20:07|I
# MSSQL_SQL0x4|msdb|2016-07-08 20:20:43|D
# MSSQL_SQL0x4|msdb|2016-07-11 20:20:07|I

DiscoveryResult = Iterable[tuple[str, Mapping]]
Result = tuple[int, str, list]
CheckResult = Iterable[Result]


class Backup(NamedTuple):
    timestamp: float | None
    type: str | None
    state: str


Section = Mapping[str, Sequence[Backup]]


_MAP_BACKUP_TYPES = {
    "D": "database",
    "I": "database diff",
    "L": "log",
    "F": "file or filegroup",
    "G": "file diff",
    "P": "partial",
    "Q": "partial diff",
    "-": "unspecific",
}


discovery_mssql_backup: list = []


def _parse_date_and_time(b_date: str, b_time: str | None) -> float | None:
    try:
        if b_time is None:
            return int(b_date)
        return time.mktime(time.strptime("%s %s" % (b_date, b_time), "%Y-%m-%d %H:%M:%S"))
    except ValueError:
        return None


def _get_word(line: Sequence[str], idx: int) -> str | None:
    try:
        return line[idx]
    except IndexError:
        return None


def parse_mssql_backup(string_table: StringTable) -> Section:

    parsed: dict[str, list[Backup]] = {}

    line: Sequence[str | None]
    for line in string_table:
        if len(line) <= 2:
            continue
        # handle one special case where spaces are in date/time:
        if len(line) == 4 and " " in line[2]:
            line = line[:2] + line[2].split(" ") + line[3:]

        inst, tablespace, b_date = line[:3]
        # (fill up with Nones)
        b_time, b_type, b_state = (_get_word(line, i) for i in (3, 4, 5))

        timestamp = _parse_date_and_time(b_date, b_time)

        item = "%s %s" % (inst, tablespace)
        backup = Backup(timestamp, _MAP_BACKUP_TYPES.get(b_type) if b_type else None, b_state or "")
        parsed.setdefault(item, []).append(backup)

    return parsed


def inventory_mssql_backup(section: Section) -> DiscoveryResult:
    discovery_mode = _mssql_backup_discovery_mode()
    if discovery_mode != "summary":
        return
    for db_name in section:
        yield db_name, {}


def _mssql_backup_discovery_mode() -> str:
    rules = host_extra_conf(host_name(), discovery_mssql_backup)
    try:
        return rules[0]["mode"]
    except (IndexError, KeyError):
        return "summary"  # default, comp. to older versions


def check_mssql_backup(item: str, params: Mapping[str, Any], section: Section) -> CheckResult:
    data = section.get(item)
    if data is None:
        # Assume general connection problem to the database, which is reported
        # by the "X Instance" service and skip this check.
        raise MKCounterWrapped("Failed to connect to database")

    for backup in data:
        if backup.state == "no backup found":
            yield params.get("not_found", 1), "No backup found", []
            continue
        if backup.state.startswith("ERROR: "):
            yield 2, backup.state[7:], []
            continue
        if backup.type is None:
            backup_type_var = "database"
            perfkey = "seconds"
            backup_type_info = "[database]"
        else:
            backup_type_var = backup.type.strip().replace(" ", "_")
            perfkey = "backup_age_%s" % backup_type_var
            backup_type_info = "[%s]" % backup.type
        yield 0, f"{backup_type_info} Last backup: {render.datetime(backup.timestamp)}", []
        yield check_levels(
            time.time() - backup.timestamp,  # type: ignore[operator]  # aparrently this does not happen
            perfkey,
            params.get(backup_type_var),
            human_readable_func=render.timespan,
            infoname="Time since last backup",
        )


check_info["mssql_backup"] = {
    "parse_function": parse_mssql_backup,
    "check_function": check_mssql_backup,
    "inventory_function": inventory_mssql_backup,
    "service_description": "MSSQL %s Backup",
    "has_perfdata": True,
    "group": "mssql_backup",
    "default_levels_variable": "mssql_backup_default_levels",
}


factory_settings["mssql_backup_default_levels"] = {
    "database": (None, None),
    "database_diff": (None, None),
    "log": (None, None),
    "file_or_filegroup": (None, None),
    "file_diff": (None, None),
    "partial": (None, None),
    "partial_diff": (None, None),
    "unspecific": (None, None),
}


# .
#   .--single--------------------------------------------------------------.
#   |                          _             _                             |
#   |                      ___(_)_ __   __ _| | ___                        |
#   |                     / __| | '_ \ / _` | |/ _ \                       |
#   |                     \__ \ | | | | (_| | |  __/                       |
#   |                     |___/_|_| |_|\__, |_|\___|                       |
#   |                                  |___/                               |
#   '----------------------------------------------------------------------'


def _mssql_backup_per_type_item(db_name: str, backup: Backup) -> str:
    if backup.type is None:
        return "%s UNKNOWN" % db_name
    return "%s %s" % (db_name, backup.type.title())


def inventory_mssql_backup_per_type(section: Section) -> DiscoveryResult:
    discovery_mode = _mssql_backup_discovery_mode()
    if discovery_mode != "per_type":
        return
    for db_name, attrs in section.items():
        for backup in attrs:
            yield _mssql_backup_per_type_item(db_name, backup), {}


def check_mssql_backup_per_type(
    item: str, params: Mapping[str, Any], section: Section
) -> CheckResult:
    for db_name, attrs in section.items():
        for backup in attrs:
            if item == _mssql_backup_per_type_item(db_name, backup):
                yield 0, f"Last backup: {render.datetime(backup.timestamp)}", []
                yield check_levels(
                    time.time() - backup.timestamp,  # type: ignore[operator]  # aparrently this does not happen
                    "backup_age",
                    params.get("levels"),
                    human_readable_func=render.timespan,
                    infoname="Time since last backup",
                )
                return
    # Assume general connection problem to the database, which is reported
    # by the "X Instance" service and skip this check.
    raise MKCounterWrapped("Failed to connect to database")


check_info["mssql_backup.per_type"] = {
    "check_function": check_mssql_backup_per_type,
    "inventory_function": inventory_mssql_backup_per_type,
    "service_description": "MSSQL %s Backup",
    "has_perfdata": True,
    "group": "mssql_backup_per_type",
}
