#!/usr/bin/env python3
# Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2
# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and
# conditions defined in the file COPYING, which is part of this source code package.

# <<<sap:sep(9)>>>
# sap_XYZ    1    50 Nagios/Allgemein/Intern/ResponseTime    249 msec
# sap_XYZ    1    50 Nagios/Allgemein/Intern/ResponseTimeDialog  249 msec
# sap_XYZ    1    50 Nagios/Allgemein/Intern/ResponseTimeDialogRFC   249 msec
# sap_XYZ    1    50 Nagios/Allgemein/Intern/ResponseTimeHTTP    9830    msec
# sap_XYZ    1    50 Nagios/Allgemein/Intern/FrontendResponseTime    542 msec
# sap_XYZ    1    50 Nagios/Allgemein/Intern/LongRunners 120 sec
# sap_XYZ    1    50 Nagios/Allgemein/Intern/ResponseTime(StandardTran.) 7   msec
# sap_XYZ    1    50 Nagios/Allgemein/Intern/UsersLoggedIn   97  -
# sap_XYZ    1    50 SAP CCMS Monitor Templates/Dialog Overview/Dialog Response Time/ResponseTime    249 msec
# sap_XYZ    1    50 SAP CCMS Monitor Templates/Dialog Overview/Network Time/FrontEndNetTime 80  msec
# sap_XYZ    1    50 SAP CCMS Monitor Templates/Dialog Overview/Standardized Response Time/ResponseTime(StandardTran.)   7   msec
# sap_XYZ    1    50 SAP CCMS Monitor Templates/Dialog Overview/Users Logged On/UsersLoggedIn    97  -

from typing import Any, Iterable, Literal, Mapping, Match, NamedTuple, Sequence

from cmk.base.plugins.agent_based.agent_based_api.v1 import regex
from cmk.base.plugins.agent_based.agent_based_api.v1.type_defs import StringTable

DiscoveryResult = Iterable[tuple[str, Mapping[str, Any]]]
CheckResult = Iterable[tuple[int, str, list]]


class Entry(NamedTuple):
    sid: str
    state: int
    path: str
    reading: float | None
    unit: str
    output: str


Section = Sequence[Entry]


# This map converts between the SAP color codes (key values) and the
# nagios state codes
_SAP_NAGIOS_STATE_MAP = {
    0: 0,  # GRAY  (inactive or no current info available) -> OK
    1: 0,  # GREEN  -> OK
    2: 1,  # YELLOW -> WARNING
    3: 2,  # RED    -> CRITICAL
}


RESPONSE_TIME_PATH = "SAP CCMS Monitor Templates/Dialog Overview/"


def _safe_float(raw: str) -> float:
    """
    Taken from legacy API for now to allow migration.
    Try to get rid of it!
    """
    try:
        return float(raw)
    except ValueError:
        return 0.0


def parse_sap(string_table: StringTable) -> Section:
    return [
        Entry(
            sid=sid,
            state=_SAP_NAGIOS_STATE_MAP[int(state)],
            path=path,
            reading=None if reading == "-" else _safe_float(reading),
            unit=unit,
            output=" ".join(output),
        )
        for sid, state, _unused, path, reading, unit, *output in string_table
    ]


check_info["sap"] = {
    "parse_function": parse_sap,
}


def inventory_sap_dialog(section: Section) -> DiscoveryResult:
    yield from (
        (entry.sid, {})
        for entry in section
        if entry.path == f"{RESPONSE_TIME_PATH}Dialog Response Time/ResponseTime"
    )


def check_sap_dialog(item: str, params: Mapping[str, Any], section: Section) -> CheckResult:
    # First extract all infos
    dialog = {
        entry.path.split("/")[-1]: (entry.reading, entry.unit)
        for entry in section
        if entry.sid == item
        and entry.path.startswith(RESPONSE_TIME_PATH)
        and entry.reading is not None
    }

    if not dialog:
        # this isn't perfect. Sap data is delivered as piggyback output. Potentially multiple
        # hosts can each send data for multiple sap instances. The data can also overlap.
        # This means technically we may not get here and report then incomplete data if one host is
        # down.
        # And we would get here if the host isn't down if the item has simply disappeared from
        # the output.
        # There is no way inside this check to determine the host(s) that sent the data in info.
        raise MKCounterWrapped("no output about sap dialogs in agent output")

    def perf_clean_key(s: str) -> str:
        return s.replace("(", "_").replace(")", "_").replace(" ", "_").replace(".", "_").rstrip("_")

    # {
    #     'UsersLoggedIn': (2, '-'),
    #     'ResponseTime(StandardTran.)': (6, 'msec'),
    #     'FrontEndNetTime': (0, 'msec'),
    #     'ResponseTime': (77, 'msec'),
    # }
    for key, value in dialog.items():
        yield check_levels(
            value[0],
            dsname=perf_clean_key(key),
            params=params.get(key),
            human_readable_func=lambda x, t=f"%.2f {'' if value[1] == '-' else value[1]}": t % x,
            infoname=key,
        )


check_info["sap.dialog"] = {
    "check_function": check_sap_dialog,
    "group": "sap_dialog",
    "inventory_function": inventory_sap_dialog,
    "service_description": "%s Dialog",
    "has_perfdata": True,
}

#
# Simple processing of nodes reported by sap agent
#

# Holds a list of rules which are matching hosts by names or tags
# and where each rule holds a dictionary of paramteters
#
# at the moment the following parameters are supported:
# 1. match: the sap-path matching definition
inventory_sap_values = []
sap_value_groups = []


def inventory_sap_value(section: Section) -> DiscoveryResult:
    patterns = []
    for value in host_extra_conf(host_name(), inventory_sap_values):
        patterns.append((value["match"], value.get("limit_item_levels")))

    for entry in section:
        for pattern, limit_item_levels in patterns:
            if sap_value_path_matches(entry.path, pattern):
                discovered_params = {}
                if limit_item_levels:
                    path = "/".join(entry.path.split("/")[-limit_item_levels:])
                    discovered_params["limit_item_levels"] = limit_item_levels
                else:
                    path = entry.path
                yield entry.sid + " " + path, discovered_params


def sap_value_path_matches(path: str, pattern: str | None) -> bool:
    if pattern is None:
        return True

    if pattern.startswith("~"):  # regex matching
        reg = regex(pattern[1:])
        return bool(reg.match(path))

    return path == pattern


def check_sap_value(item: str, params: Mapping[str, Any], section: Section) -> CheckResult:
    status = None
    perfdata = []
    limit = params.get("limit_item_levels")

    for entry in section:
        this_path = "/".join(entry.path.split("/")[-limit:]) if limit else entry.path

        if entry.sid + " " + this_path == item:
            status = entry.state
            if entry.reading is not None:
                # This is a performance value, has no output
                perfdata = [("value", entry.reading)]
                output = "%0.2f%s" % (entry.reading, entry.unit)
            else:
                # This is a status field without perfdata
                output = entry.output
            break

    if status is None:
        raise MKCounterWrapped("no output about sap value in agent output")

    yield status, output, perfdata


check_info["sap.value"] = {
    "check_function": check_sap_value,
    "inventory_function": inventory_sap_value,
    "service_description": "%s",
    "has_perfdata": True,
}

GroupPatterns = list[tuple[str, str]]
SAPRules = list[tuple[str, tuple[str, str]]]


def _patterns_match(
    name: str, exclusion: str | None, inclusion: str
) -> Literal[False] | Match[str] | None:
    if exclusion and regex(exclusion).match(name):
        return False
    return regex(inclusion).match(name)


def sap_groups_of_value(
    value_name: str,
    patterns: SAPRules,
) -> set[str]:
    return {
        group_name
        for group_name, (inclusion, exclusion) in patterns
        if _patterns_match(value_name, exclusion, inclusion)
    }


def get_patterns_by_group_name(patterns: SAPRules) -> Mapping[str, GroupPatterns]:
    rules_by_group: dict[str, GroupPatterns] = {}
    for group_name, (inclusion, exclusion) in patterns:
        rules_by_group.setdefault(group_name, []).append((inclusion, exclusion))
    return rules_by_group


def discover_sap_value_groups(section: Section) -> DiscoveryResult:
    # TODO: this becomes a proper argument in the new API
    params = host_extra_conf(host_name(), sap_value_groups)
    groups: SAPRules = [
        pattern
        for parameter_set in params
        for pattern in parameter_set.get("grouping_patterns", [])
    ]
    patterns_by_group = get_patterns_by_group_name(groups)

    yield from (
        (item, {"_group_relevant_patterns": patterns_by_group[item]})
        for entry in section
        for item in sap_groups_of_value(entry.path, groups)
    )


def check_sap_value_groups(item: str, params: Mapping[str, Any], section: Section) -> CheckResult:

    try:
        patterns: GroupPatterns = params["_group_relevant_patterns"]
    except KeyError:
        yield 3, "Rules not found. Please rediscover the services of this host", []
        return

    # this fake rules instance already only contains relevant patterns
    precompiled_rule = [(item, pattern) for pattern in patterns]

    non_ok_results: list[tuple[int, str, list]] = []
    all_results: list[tuple[int, str, list]] = []
    count_ok, count_crit = 0, 0
    for entry in section:
        if item in sap_groups_of_value(entry.path, precompiled_rule):
            status = entry.state
            output = entry.output if entry.reading is None else ""

            all_results.append((status, entry.path + output, []))
            if status > 0:
                count_crit += 1
                non_ok_results.append((status, entry.path + output, []))
            else:
                count_ok += 1

    if not all_results:
        raise MKCounterWrapped("no output about sap value groups in agent output")

    yield 0, "%s OK, %s Critical" % (count_ok, count_crit), []

    for result in non_ok_results:
        yield result

    for state, text, metric in all_results:
        yield state, "\n%s" % text, metric


check_info["sap.value_groups"] = {
    "check_function": check_sap_value_groups,
    "inventory_function": discover_sap_value_groups,
    "service_description": "%s",
}
