#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2
# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and
# conditions defined in the file COPYING, which is part of this source code package.

import typing

# NOTE: Careful when replacing the *-import below with a more specific import. This can cause
# problems because it might remove variables needed for accessing discovery rulesets.
from cmk.base.check_legacy_includes.oracle import *  # pylint: disable=wildcard-import,unused-wildcard-import

# In cooperation with Thorsten Bruhns from OPITZ Consulting

# <<<oracle_processes>>>
# TUX2 51 300
# FOOBAR 11 4780

# Columns: SID PROCESSES_COUNT PROCESSES_LIMIT

factory_settings["oracle_processes_defaults"] = {
    "levels": (70.0, 90.0),
}


class OracleProcess(typing.NamedTuple):
    name: str
    processes_count: int
    processes_limit: int


ErrorProcesses = typing.Mapping[str, typing.Optional[typing.Tuple[int, str]]]
OracleProcesses = typing.Mapping[str, OracleProcess]


class SectionOracleProcesses(typing.NamedTuple):
    error_processes: ErrorProcesses
    oracle_processes: OracleProcesses


def parse_oracle_processes(info):
    valid_oracle_processes: typing.MutableMapping[str, OracleProcess] = {}
    error_processes: typing.MutableMapping[str, typing.Tuple[int, str]] = {}

    for line in info:
        err = oracle_handle_ora_errors(line)
        process_name = line[0]
        if err is False:
            continue
        if isinstance(err, tuple):
            error_processes[process_name] = err
        else:
            valid_oracle_processes[process_name] = OracleProcess(
                name=process_name, processes_count=int(line[1]), processes_limit=int(line[2])
            )

    return SectionOracleProcesses(
        error_processes=error_processes, oracle_processes=valid_oracle_processes
    )


def discover_oracle_processes(section):
    for process in section.error_processes:
        yield process, {}

    for process in section.oracle_processes:
        yield process, {}


def check_oracle_processes(item, params, section):

    if ora_error := section.error_processes.get(item):
        return ora_error[0], ora_error[1]

    # In case of missing information we assume that the login into
    # the database has failed and we simply skip this check. It won't
    # switch to UNKNOWN, but will get stale.
    if not (process := section.oracle_processes.get(item)):
        raise MKCounterWrapped("Login into database failed")

    processes_pct = float(process.processes_count / process.processes_limit) * 100

    warn, crit = params["levels"]
    state, summary, _ = check_levels(
        value=processes_pct,
        dsname=None,
        params=(warn, crit),
        infoname=f"{process.processes_count} of {process.processes_limit} processes are used",
        human_readable_func=get_percent_human_readable,
    )
    return (
        state,
        summary,
        [
            (
                "processes",
                process.processes_count,
                process.processes_limit * (warn / 100),
                process.processes_limit * (crit / 100),
            )
        ],
    )


check_info["oracle_processes"] = {
    "parse_function": parse_oracle_processes,
    "check_function": check_oracle_processes,
    "inventory_function": discover_oracle_processes,
    "service_description": "ORA %s Processes",
    "has_perfdata": True,
    "default_levels_variable": "oracle_processes_defaults",
    "group": "oracle_processes",
}
