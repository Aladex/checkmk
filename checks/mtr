#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2
# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and
# conditions defined in the file COPYING, which is part of this source code package.

# Example for output from agent
# ---------------------------------------------------------
#<<<mtr>>>
#www.google.com|1451237587|8|80.69.76.120|0.0%|10|39.2|7.0|0.3|39.2|14.2|80.249.209.100|0.0%|10|1.2|1.2|1.0|1.4|0.0|209.85.240.61|0.0%|10|1.4|1.6|1.2|2.4|0.0|209.85.248.247|0.0%|10|1.6|1.7|1.5|2.1|0.0|216.239.51.17|0.0%|10|4.8|5.0|4.7|5.3|0.0|216.239.49.36|0.0%|10|6.1|5.5|4.7|8.8|1.1|???|100.0|10|0.0|0.0|0.0|0.0|0.0|74.125.136.105|0.0%|10|4.7|5.0|4.7|5.4|0.0
# ---------------------------------------------------------

factory_settings["mtr_default_levels"] = {
    "pl": (10, 25),  # warn/crit for loss percentage
    "rta": (150, 250),  # warn/crit for average roundtrip time
    "rtstddev": (150, 250),  # warn/crit for standard deviation
}


def inventory_mtr(parsed):
    for host in parsed:
        yield host, {}


def _metrics_nonlast_hops(hops):
    for idx, hop in enumerate(
            hops,
            start=1,
    ):
        yield ('hop_%d_rta' % idx, hop.rta)
        yield ('hop_%d_rtmin' % idx, hop.rtmin)
        yield ('hop_%d_rtmax' % idx, hop.rtmax)
        yield ('hop_%d_rtstddev' % idx, hop.rtstddev)
        yield ('hop_%d_response_time' % idx, hop.response_time)
        yield ('hop_%d_pl' % idx, hop.pl)


def _results_last_hop(
    params,
    last_hop,
    last_idx,
):
    states = []
    texts = []
    perfdata = []

    state, text, pdata = check_levels(
        last_hop.pl,
        'hop_%d_pl' % last_idx,
        params["pl"],
        human_readable_func=get_percent_human_readable,
        infoname="Packet loss",
    )
    states.append(state)
    texts.append(text)
    perfdata.extend(pdata)

    state, text, pdata = check_levels(
        last_hop.rta,
        'hop_%d_rta' % last_idx,
        (params["rta"][0] / 1000, params["rta"][1] / 1000),
        human_readable_func=get_age_human_readable,
        infoname="Round trip average",
    )
    states.append(state)
    texts.append(text)
    perfdata.extend(pdata)

    state, text, pdata = check_levels(
        last_hop.rtstddev,
        'hop_%d_rtstddev' % last_idx,
        (params["rtstddev"][0] / 1000, params["rtstddev"][1] / 1000),
        human_readable_func=get_age_human_readable,
        infoname="Standard deviation",
    )
    states.append(state)
    texts.append(text)
    perfdata.extend(pdata)

    perfdata.append(('hop_%d_rtmin' % last_idx, last_hop.rtmin))
    perfdata.append(('hop_%d_rtmax' % last_idx, last_hop.rtmax))
    perfdata.append(('hop_%d_response_time' % last_idx, last_hop.response_time))

    return max(states), ", ".join(texts), perfdata


def check_mtr(item, params, parsed):
    if (hops := parsed.get(item)) is None:
        return

    if not hops:
        yield 3, "Insufficient data: No hop information available"
        return

    yield 0, "Number of Hops: %d" % len(hops), [('hops', len(hops))]

    perfdata_nonlast = [*_metrics_nonlast_hops(hops[:-1])]
    state_last, text_last, perfdata_last = _results_last_hop(
        params,
        hops[-1],
        len(hops),
    )

    yield (
        state_last,
        text_last + "\n" + "\n".join("Hop %d: %s" % (
            idx + 1,
            hop.name,
        ) for idx, hop in enumerate(hops)),
        perfdata_nonlast + perfdata_last,
    )


check_info['mtr'] = {
    "check_function": check_mtr,
    "inventory_function": inventory_mtr,
    "service_description": "Mtr to %s",
    "has_perfdata": True,
    "group": "mtr",
    "default_levels_variable": "mtr_default_levels",
}
