#!/usr/bin/env python3
# Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2
# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and
# conditions defined in the file COPYING, which is part of this source code package.

import sys

# NOTE: Careful when replacing the *-import below with a more specific import. This can cause
# problems because it might remove variables needed for accessing discovery rulesets.
from typing import Any, Mapping, NamedTuple

from cmk.base.check_legacy_includes.temperature import *  # pylint: disable=wildcard-import,unused-wildcard-import
from cmk.base.plugins.agent_based.agent_based_api.v1.type_defs import StringTable

factory_settings["ups_modulys_battery_default_levels"] = {"capacity": (95, 90), "battime": (0, 0)}


class UPSBattery(NamedTuple):
    health: int
    uptime: int
    remaining_time_in_min: int
    capacity: int
    temperature: int | None


UPSBatterySection = UPSBattery | None


def parse_ups_modulys_battery(string_table: StringTable) -> UPSBatterySection:
    try:
        raw_health, raw_uptime, raw_remaining_time, raw_capacity, raw_temperature = string_table[0]
    except (IndexError, ValueError):
        return None

    if not raw_uptime or int(raw_uptime) == 0:
        # The "raw_remaining_time" value isn't always reported and we don't know why.
        # One theory is that it will be reported if on battery but we have no data to verify.
        # If the theory holds true, this branch is never taken. If it doesn't then its likely
        # the information is only available on some variants of the device or in some
        # configurations. We can still report useful data based on "capacity"

        # If the "raw_remaining_time" value is 0, it means that the device is not on battery so the it will not run out
        remaining_time_in_min = sys.maxsize
    else:
        remaining_time_in_min = int(raw_remaining_time)

    try:
        # Sometimes it could happen that the temperature is not reported
        temperature = int(raw_temperature)
    except ValueError:
        temperature = None

    return UPSBattery(
        health=int(raw_health),
        uptime=int(raw_uptime),
        remaining_time_in_min=remaining_time_in_min,
        capacity=int(raw_capacity),
        temperature=temperature,
    )


def inventory_ups_modulys_battery(section: UPSBatterySection):
    if section:
        yield None, {}


def check_ups_modulys_battery(
    item: str, params: Mapping[str, Any], section: UPSBatterySection
):  # pylint: disable=too-many-branches
    warn_left, crit_left = params["battime"]
    warn_perc, crit_perc = params["capacity"]
    if section is None:
        return

    # test 1: on mains or on battery?
    if section.uptime == 0:
        yield 0, "on mains"
    else:
        # we already have configurable levels on remaining capacity which
        # would be superfluous if we reported the discharging state itself
        # as a problem. Thus this reports "OK"
        yield 0, "discharging for %d minutes" % (section.uptime // 60)

    # test 2: battery health
    if section.health == 1:
        yield 1, "battery health weak"
    elif section.health == 2:
        yield 2, "battery needs to be replaced"

    # test 3: remaining capacity
    if section.remaining_time_in_min < crit_left or section.capacity < crit_perc:
        status = 2
    elif section.remaining_time_in_min < warn_left or section.capacity < warn_perc:
        status = 1
    else:
        status = 0

    infotext = ""

    if section.remaining_time_in_min < warn_left:
        infotext = "%d minutes remaining (warn/crit at %d/%d min)" % (
            section.remaining_time_in_min,
            warn_left,
            crit_left,
        )

    if section.capacity < warn_perc:
        infotext = "%d percent charged (warn/crit at %d/%d perc)" % (
            section.capacity,
            warn_perc,
            crit_perc,
        )

    yield status, infotext


check_info["ups_modulys_battery"] = {
    "parse_function": parse_ups_modulys_battery,
    "inventory_function": inventory_ups_modulys_battery,
    "check_function": check_ups_modulys_battery,
    "service_description": "Battery Charge",
    "default_levels_variable": "ups_modulys_battery_default_levels",
    "group": "ups_capacity",
    "snmp_info": (
        ".1.3.6.1.4.1.2254.2.4.7",
        [
            "1",  # dupsBatteryCondition
            "4",  # dupsSecondsOnBattery
            "5",  # dupsBatteryEstimatedTime
            "8",  # dupsBatteryCapacity
            "9",  # dupsBatteryTemperature
        ],
    ),
    "snmp_scan_function": lambda oid: oid(".1.3.6.1.2.1.1.2.0") == ".1.3.6.1.4.1.2254.2.4",
}


def inventory_ups_modulys_battery_temp(section: UPSBatterySection):
    if section and section.temperature is not None:
        yield ("Battery", {})


def check_ups_modulys_battery_temp(item: str, params: TempParamType, section: UPSBatterySection):

    if section and section.temperature is not None:
        yield check_temperature(
            section.temperature,
            params,
            f"ups_modulys_battery_temp_{item}",
        )


check_info["ups_modulys_battery.temp"] = {
    "inventory_function": inventory_ups_modulys_battery_temp,
    "check_function": check_ups_modulys_battery_temp,
    "has_perfdata": True,
    "service_description": "Temperature %s",
    "group": "temperature",
    "default_levels_variable": "ups_modulys_battery_temp_default_levels",
}
