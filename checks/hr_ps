#!/usr/bin/env python3
# Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2
# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and
# conditions defined in the file COPYING, which is part of this source code package.

from typing import Any, Iterable, Mapping, Match, NamedTuple, Sequence

import cmk.base.plugins.agent_based.utils.ps as ps

# NOTE: Careful when replacing the *-import below with a more specific import. This can cause
# problems because it might remove variables needed for accessing discovery rulesets.
from cmk.base.check_legacy_includes.ucd_hr import *  # pylint: disable=wildcard-import,unused-wildcard-import
from cmk.base.plugins.agent_based.agent_based_api.v1 import regex
from cmk.base.plugins.agent_based.agent_based_api.v1.type_defs import StringTable

DiscoveryResult = Iterable[tuple[str, Mapping]]
CheckResult = Iterable[tuple[int, str, list] | tuple[int, str]]


discovery_hr_processes_rules = []

_HR_PS_STATUS_MAP = {
    "1": ("running", "running", ""),
    "2": ("runnable", "runnable", "waiting for resource"),
    "3": ("not_runnable", "not runnable", "loaded but waiting for event"),
    "4": ("invalid", "invalid", "not loaded"),
}


class HRProcess(NamedTuple):
    name: str
    path: str
    state_key: str
    state_short: str
    state_long: str


Section = Sequence[HRProcess]


factory_settings["hr_ps_default_levels"] = {
    "levels": (1, 1, 99999, 99999),
}


def parse_hr_ps(string_table: StringTable) -> Section:
    parsed = []
    for name, path, status in string_table:
        key, short, long_ = _HR_PS_STATUS_MAP.get(status, (status, "unknown[%s]" % status, ""))
        parsed.append(HRProcess(name.strip(":"), path, key, short, long_))
    return parsed


def discover_hr_ps(section: Section) -> DiscoveryResult:
    params = host_extra_conf(host_name(), discovery_hr_processes_rules)
    discovered_items: dict[str, Mapping[str, Any]] = {}
    for process in section:
        for rule in params:
            match_name_or_path = rule.get("match_name_or_path")
            match_status = rule.get("match_status")

            matches = _match_hr_process(process, match_name_or_path, match_status, None)
            if not matches:
                continue

            if matches is True:
                match_groups = []
            else:
                match_groups = [g if g else "" for g in matches.groups()]

            service_descr = ps.replace_service_description(
                rule["descr"], match_groups, match_name_or_path
            )

            discovered_items.setdefault(
                service_descr,
                {
                    "match_name_or_path": match_name_or_path,
                    "match_status": match_status,
                    "match_groups": match_groups,
                },
            )
    return list(discovered_items.items())


def check_hr_ps(item: str, params: Mapping[str, Any], section: Section) -> CheckResult:
    match_name_or_path = params.get("match_name_or_path")
    match_status = params.get("match_status")
    match_groups = params.get("match_groups")

    count_processes = 0
    processes_by_state: dict[tuple[str, str, str], list[HRProcess]] = {}
    for process in section:
        if _match_hr_process(process, match_name_or_path, match_status, match_groups):
            count_processes += 1
            processes_by_state.setdefault(
                (process.state_key, process.state_short, process.state_long), []
            ).append(process)

    lc, lw, uw, uc = params.get("levels", (None, None, None, None))
    yield check_levels(
        count_processes, "processes", (uw, uc, lw, lc), unit="processes", human_readable_func=int
    )

    process_state_map = dict(params.get("status", []))
    for (state_key, state_short, state_long), processes in processes_by_state.items():
        state = process_state_map.get(state_key, 0)
        if state_long:
            state_info = "%s (%s)" % (state_short, state_long)
        else:
            state_info = state_short
        yield state, "%s %s" % (len(processes), state_info)


def _match_hr_process(
    process: HRProcess,
    match_name_or_path: Any,  # str, tuple, None ???
    match_status: Sequence[str] | None,
    match_groups: list[str] | None,
) -> bool | Match[str]:
    if match_status and process.state_key not in match_status:
        return False

    if not match_name_or_path or match_name_or_path == "match_all":
        return True

    match_type, match_pattern = match_name_or_path
    pattern_to_match = {
        "match_name": process.name,
        "match_path": process.path,
    }[match_type]

    if match_pattern is not None and match_pattern.startswith("~"):
        # Regex for complete process name or path
        reg = regex(match_pattern[1:])  # skip "~"
        m = reg.match(pattern_to_match)
        if not m:
            return False
        if match_groups:
            return m.groups() == tuple(match_groups)
        return m

    # Exact match on name of executable
    return pattern_to_match == match_pattern


check_info["hr_ps"] = {
    "parse_function": parse_hr_ps,
    "inventory_function": discover_hr_ps,
    "check_function": check_hr_ps,
    "service_description": "Process %s",
    "snmp_scan_function": is_hr,
    "snmp_info": (
        ".1.3.6.1.2.1.25.4.2.1",
        [  # HOST-RESOURCES-MIB
            "2",  # hrSWRunName
            "4",  # hrSWRunPath
            "7",  # hrSWRunStatus
        ],
    ),
    "group": "hr_ps",
    "default_levels_variable": "hr_ps_default_levels",
}
