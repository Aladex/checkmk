#!/usr/bin/env python3
# Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2
# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and
# conditions defined in the file COPYING, which is part of this source code package.
from typing import Any, List, Mapping, TypedDict

from cmk.base.check_legacy_includes.cisco_cpu_scan_functions import snmp_scan_cisco_cpu_multiitem
from cmk.base.check_legacy_includes.cisco_mem import check_cisco_mem_sub
from cmk.base.plugins.agent_based.agent_based_api.v1.type_defs import StringTable


class MemInfo(TypedDict):
    mem_used: int
    mem_free: int
    mem_reserved: int


Section = Mapping[str, MemInfo]


def _to_bytes(raw: str) -> int:
    return int(float(raw) * 1024)


def parse_cisco_cpu_memory_multiitem(string_table: List[StringTable]) -> Section:
    ph_idx_to_desc = {
        idx: desc[4:] if desc.lower().startswith("cpu ") else desc for idx, desc in string_table[1]
    }

    parsed: dict[str, MemInfo] = {}
    for idx, used, free, reserved in string_table[0]:
        if used == "0" and free == "0":
            continue

        name = ph_idx_to_desc.get(idx, idx)
        try:
            parsed[name] = {
                "mem_used": _to_bytes(used),
                "mem_free": _to_bytes(free),
                "mem_reserved": _to_bytes(reserved),
            }
        except ValueError:
            pass
    return parsed


check_info["cisco_cpu_memory"] = {
    "parse_function": parse_cisco_cpu_memory_multiitem,
    "snmp_info": [
        (
            ".1.3.6.1.4.1.9.9.109.1.1.1",
            [
                "1.2",  # cpmCPUTotalPhysicalIndex
                "1.12",  # cpmCPUMemoryUsed
                "1.13",  # cpmCPUMemoryFree
                "1.14",  # cpmCPUMemoryKernelReserved
            ],
        ),
        (
            ".1.3.6.1.2.1.47.1.1.1",
            [
                OID_END,  # OID index
                "1.7",  # entPhysicalName
            ],
        ),
    ],
    "snmp_scan_function": snmp_scan_cisco_cpu_multiitem,
}


def discover_cisco_cpu_memory_multiitem(section: Section):
    yield from ((key, {}) for key in section)


def check_cisco_cpu_memory_multiitem(item: str, params: Mapping[str, Any], section: Section):
    if (data := section.get(item)) is None:
        return
    mem_used = data["mem_used"]
    mem_free = data["mem_free"]
    mem_reserved = data["mem_reserved"]
    mem_occupied = mem_used + mem_reserved
    mem_total = mem_used + mem_free
    yield check_cisco_mem_sub(None, params, mem_occupied, mem_total)


check_info["cisco_cpu_memory"].update(
    {
        "check_function": check_cisco_cpu_memory_multiitem,
        "inventory_function": discover_cisco_cpu_memory_multiitem,
        "group": "cisco_cpu_memory",
        "service_description": "CPU Memory utilization %s",
        "has_perfdata": True,
    }
)
