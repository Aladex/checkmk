#!/usr/bin/env python3
# Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2
# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and
# conditions defined in the file COPYING, which is part of this source code package.

# The etherbox supports the following sensor types on each port
# sensor types
# 0 = no sensor
# 1 = temperature      - implemented
# 2 = brightness
# 3 = humidity         - implemented
# 4 = switch contact   - implemented
# 5 = voltage detector
# 6 = smoke sensor     - implemented

# Note: The short contact config option in the etherbox is of type switch contact
#       The short contact status is set for 15 seconds after a button press

from dataclasses import dataclass
from typing import Any, Iterable, Mapping

from cmk.base.check_legacy_includes.humidity import *  # pylint: disable=wildcard-import,unused-wildcard-import
from cmk.base.check_legacy_includes.temperature import *  # pylint: disable=wildcard-import,unused-wildcard-import
from cmk.base.plugins.agent_based.agent_based_api.v1 import State

# TODO: insert missing snmp output

ServiceType = tuple[str, None]


def Service(item: str) -> ServiceType:
    return item, None


DiscoveryResult = Iterable[ServiceType]
StringByteTable = List[List[Union[str, List[str]]]]
CheckResult = Iterable[Any]


@dataclass(frozen=True)
class SensorData:
    name: str
    value: int


Index = str
Type = str


@dataclass(frozen=True)
class Section:
    unit_of_measurement: str
    sensor_data: Mapping[Index, Mapping[Type, SensorData]]


# placeholder to delete and replace with imports during migration
def Result(state: State, summary: str) -> tuple[State, str]:
    return (state, summary)


def Metric(name: str, value: float) -> tuple[str, str, list[tuple[str, float]]]:
    return "", "", [(name, value)]


def etherbox_convert(string_table) -> Section:
    unit_of_measurement = {"0": "c", "1": "f", "2": "k"}[string_table[0][0][0]]
    data: dict[Index, dict[Type, SensorData]] = {}
    for i in range(0, len(string_table[1])):
        index, sensor_type = string_table[1][i][1], string_table[3][i][1]
        if index not in data:
            data[index] = {}
        data[index][sensor_type] = SensorData(string_table[2][i][1], int(string_table[4][i][1]))
    return Section(unit_of_measurement, data)


def etherbox_scan(oid):
    # 2015:
    # Older firmware version of Etherbox do not answer on
    # .1.3.6.1.2.1. (sysDescr). Yurks. We need to fetch
    # a vendor specific OID here and wait until all old devices
    # have vanished.
    return oid(".1.3.6.1.4.1.14848.2.1.1.1.0", "").startswith("Version")
    # 2021:
    # Have they yet? How do we know? Anyway: better would be the following,
    # but we need to known what's in the sysDescr in the good case.
    # return (
    #    "etherbox" in oid(".1.3.6.1.2.1.1.1.0").lower() or  # TODO: "etherbox" is a wild guess
    #    (not oid(".1.3.6.1.2.1.1.1.0") and
    #     oid(".1.3.6.1.4.1.14848.2.1.1.1.0", "").startswith("Version"))
    # )


etherbox_info = [
    (".1.3.6.1.4.1.14848.2.1.1.3", [""]),  # temperature unit
    (".1.3.6.1.4.1.14848.2.1.2.1.1", [OID_END, ""]),  # index
    (".1.3.6.1.4.1.14848.2.1.2.1.2", [OID_END, ""]),  # name
    (".1.3.6.1.4.1.14848.2.1.2.1.3", [OID_END, ""]),  # type
    (".1.3.6.1.4.1.14848.2.1.2.1.5", [OID_END, ""]),  # value * 10
]


def discovery(info: StringByteTable, req_sensor_type: str) -> DiscoveryResult:
    section = etherbox_convert(info)
    for index, index_data in section.sensor_data.items():
        for sensor_type, data in index_data.items():
            if sensor_type in ("1", "3") and data.value == 0:
                continue
            if sensor_type == req_sensor_type:
                yield Service(f"{index}.{sensor_type}")


def etherbox_get_sensor(item: str, section: Section) -> SensorData:
    item_index, item_type = item.split(".")
    if item_index not in section.sensor_data:
        raise Exception("Sensor not found")
    if item_type not in section.sensor_data[item_index]:
        raise Exception(f"Sensor type changed {item}")
    return section.sensor_data[item_index][item_type]


#   .--temperature---------------------------------------------------------.
#   |      _                                      _                        |
#   |     | |_ ___ _ __ ___  _ __   ___ _ __ __ _| |_ _   _ _ __ ___       |
#   |     | __/ _ \ '_ ` _ \| '_ \ / _ \ '__/ _` | __| | | | '__/ _ \      |
#   |     | ||  __/ | | | | | |_) |  __/ | | (_| | |_| |_| | | |  __/      |
#   |      \__\___|_| |_| |_| .__/ \___|_|  \__,_|\__|\__,_|_|  \___|      |
#   |                       |_|                                            |
#   '----------------------------------------------------------------------'


def check_etherbox_temp(item: str, params: Mapping[str, Any], info: StringByteTable) -> CheckResult:
    try:
        section = etherbox_convert(info)
        data = etherbox_get_sensor(item, section)
    except Exception as error:
        yield Result(state=State.UNKNOWN, summary=str(error))
        return

    temp = data.value / 10.0
    state, infotext, perfdata = check_temperature(
        temp, params, "etherbox_temp_%s" % item, section.unit_of_measurement
    )
    yield Result(state=State(state), summary=f"[{data.name}] {infotext}")
    yield "", "", perfdata


def discovery_temp(section: Section) -> DiscoveryResult:
    yield from discovery(section, "1")


check_info["etherbox.temp"] = {
    "check_function": check_etherbox_temp,
    "inventory_function": discovery_temp,
    "service_description": "Temperature %s",
    "has_perfdata": True,
    "group": "temperature",
    "snmp_scan_function": etherbox_scan,
    "snmp_info": etherbox_info,
}

# .
#   .--humidity------------------------------------------------------------.
#   |              _                     _     _ _ _                       |
#   |             | |__  _   _ _ __ ___ (_) __| (_) |_ _   _               |
#   |             | '_ \| | | | '_ ` _ \| |/ _` | | __| | | |              |
#   |             | | | | |_| | | | | | | | (_| | | |_| |_| |              |
#   |             |_| |_|\__,_|_| |_| |_|_|\__,_|_|\__|\__, |              |
#   |                                                  |___/               |
#   '----------------------------------------------------------------------'


def check_etherbox_humidity(
    item: str, params: Mapping[str, Any], info: StringByteTable
) -> CheckResult:
    try:
        section = etherbox_convert(info)
        data = etherbox_get_sensor(item, section)
    except Exception as error:
        yield Result(state=State.UNKNOWN, summary=str(error))
        return

    state, infotext, perfdata = check_humidity(data.value / 10.0, params)
    yield Result(state=State(state), summary=f"[{data.name}] {infotext}")
    yield "", "", perfdata


def discovery_humidity(section: Section) -> DiscoveryResult:
    yield from discovery(section, "3")


check_info["etherbox.humidity"] = {
    "check_function": check_etherbox_humidity,
    "inventory_function": discovery_humidity,
    "service_description": "Sensor %s",
    "has_perfdata": True,
    "group": "humidity",
    "snmp_scan_function": etherbox_scan,
    "snmp_info": etherbox_info,
}

# .
#   .--switch contact------------------------------------------------------.
#   |               _ _       _                       _             _      |
#   |  _____      _(_) |_ ___| |__     ___ ___  _ __ | |_ __ _  ___| |_    |
#   | / __\ \ /\ / / | __/ __| '_ \   / __/ _ \| '_ \| __/ _` |/ __| __|   |
#   | \__ \\ V  V /| | || (__| | | | | (_| (_) | | | | || (_| | (__| |_    |
#   | |___/ \_/\_/ |_|\__\___|_| |_|  \___\___/|_| |_|\__\__,_|\___|\__|   |
#   |                                                                      |
#   '----------------------------------------------------------------------'


def check_etherbox_switch_contact(
    item: str, params: Mapping[str, Any], info: StringByteTable
) -> CheckResult:
    try:
        section = etherbox_convert(info)
        data = etherbox_get_sensor(item, section)
    except Exception as error:
        yield Result(state=State.UNKNOWN, summary=str(error))
        return

    state = State.OK
    switch_state = "open" if data.value == 1000 else "closed"

    extra_info = ""
    if (param_state := params["state"]) != "ignore" and switch_state != param_state:
        state = State.CRIT
        extra_info = f", should be {params}"

    infotext = f"Switch contact {switch_state}{extra_info}"
    yield Result(state=state, summary=f"[{data.name}] {infotext}")
    yield Metric("switch_contact", data.value)


def discovery_switch(section: Section) -> DiscoveryResult:
    yield from discovery(section, "4")


check_info["etherbox.switch"] = {
    "check_function": check_etherbox_switch_contact,
    "inventory_function": discovery_switch,
    "service_description": "Sensor %s",
    "group": "switch_contact",
    "has_perfdata": True,
    "snmp_scan_function": etherbox_scan,
    "snmp_info": etherbox_info,
}

# .
#   .--smoke---------------------------------------------------------------.
#   |                                        _                             |
#   |                    ___ _ __ ___   ___ | | _____                      |
#   |                   / __| '_ ` _ \ / _ \| |/ / _ \                     |
#   |                   \__ \ | | | | | (_) |   <  __/                     |
#   |                   |___/_| |_| |_|\___/|_|\_\___|                     |
#   |                                                                      |
#   '----------------------------------------------------------------------'


def check_etherbox_smoke(
    item: str, no_params: Mapping[str, Any], info: StringByteTable
) -> CheckResult:
    try:
        section = etherbox_convert(info)
        data = etherbox_get_sensor(item, section)
    except Exception as error:
        yield Result(state=State.UNKNOWN, summary=str(error))
        return

    state = State.OK
    infotext = "Status: OK"
    if data.value != 0:
        infotext = "Status: smoke alarm"
        state = State.CRIT
    yield Result(state=state, summary=f"[{data.name}] {infotext}")
    yield Metric(name="smoke", value=data.value)


def discovery_smoke(section: Section) -> DiscoveryResult:
    yield from discovery(section, "6")


check_info["etherbox.smoke"] = {
    "check_function": check_etherbox_smoke,
    "inventory_function": discovery_smoke,
    "service_description": "Sensor %s",
    "has_perfdata": True,
    "snmp_scan_function": etherbox_scan,
    "snmp_info": etherbox_info,
}
